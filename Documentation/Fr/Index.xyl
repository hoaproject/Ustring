<?xml version="1.0" encoding="utf-8"?>

<overlay xmlns="http://hoa-project.net/xyl/xylophone">
<yield id="chapter">

  <p>Les chaînes de caractères peuvent parfois être <strong>complexes</strong>,
  particulièrement lorsqu'elles utilisent l'encodage <strong>Unicode</strong>.
  La bibliothèque <code>Hoa\String</code> propose plusieurs opérations de
  chaînes de caractères UTF-8.</p>

  <h2 id="Table_des_matieres">Table des matières</h2>

  <tableofcontents id="main-toc" />

  <h2 id="Introduction" for="main-toc">Introduction</h2>

  <p>Lorsque que nous manipulons des chaînes de caractères, le format <a
  href="http://unicode.org/">Unicode</a> s'impose par sa
  <strong>compatibilité</strong> avec les formats de base historiques (comme
  ASCII) et par sa grande capacité à comprendre une très <strong>large</strong>
  plage de caractères et de symboles, pour toutes les cultures et toutes les
  régions de notre monde. PHP propose plusieurs outils pour manipuler de telles
  chaînes, comme les extensions
  <a href="http://php.net/mbstring"><code>mbstring</code></a>,
  <a href="http://php.net/iconv"><code>iconv</code></a> ou encore l'excellente
  <a href="http://php.net/intl"><code>intl</code></a> qui se base sur
  <a href="http://icu-project.org/">ICU</a>, l'implémentation de référence
  d'Unicode. Malheureusement, il faut parfois mélanger ces extensions pour
  arriver à nos fins et au prix d'une certaine <strong>complexité</strong> et
  d'une <strong>verbosité</strong> regrettable.</p>
  <p>La bibliothèque <code>Hoa\String</code> répond à ces problématiques en
  proposant une façon <strong>simple</strong> de manipuler des chaînes de
  caractères, de manière <strong>performante</strong> et
  <strong>efficace</strong>. Elle propose également des algorithmes évolués pour
  des opérations de <strong>recherche</strong> sur des chaînes de
  caractères.</p>

  <h2 id="Chaine_de_caracteres_Unicode" for="main-toc">Chaîne de caractères
  Unicode</h2>

  <p>La classe <code>Hoa\String</code> représente une chaîne de caractères
  Unicode <strong>UTF-8</strong> et permet de la manipuler facilement. Elle
  implémente les interfaces
  <a href="http://php.net/arrayaccess"><code>ArrayAccess</code></a>,
  <a href="http://php.net/countable"><code>Countable</code></a> et
  <a href="http://php.net/iteratoraggregate"><code>IteratorAggregate</code></a>.
  Nous allons utiliser trois exemples dans trois langues différentes : français,
  arabe et japonais. Ainsi :</p>
  <pre><code class="language-php">$french   = new Hoa\String('Je t\'aime');
$arabic   = new Hoa\String('أحبك');
$japanese = new Hoa\String('私はあなたを愛して');</code></pre>
  <p>Maintenant, voyons les opérations possibles sur ces trois chaînes.</p>

  <h3 id="Manipulation_de_la_chaine" for="main-toc">Manipulation de la
  chaîne</h3>

  <p>Commençons par les opérations <strong>élémentaires</strong>. Si nous
  voulons <strong>compter</strong> le nombre de caractères (et non pas
  d'octets), nous allons utiliser <a href="http://php.net/count">la fonction
  <code>count</code></a> de PHP. Ainsi :</p>
  <pre><code class="language-php">var_dump(
    count($french),
    count($arabic),
    count($japanese)
);

/**
 * Will output:
 *     int(9)
 *     int(4)
 *     int(9)
 */</code></pre>
  <p>Quand nous parlons de position sur un texte, il n'est pas adéquat de parler
  de droite ou de gauche, mais plutôt de <strong>début</strong> ou de
  <strong>fin</strong>, et cela à partir de la <strong>direction</strong> (sens
  d'écriture) du texte. Nous pouvons connaître cette direction grâce à la
  méthode <code>Hoa\String::getDirection</code>. Elle retourne la valeur d'une
  des constantes suivantes :</p>
  <ul>
    <li><code>Hoa\String::LTR</code>, pour <em lang="en">left-to-right</em>, si
    le texte s'écrit de gauche à droite ;</li>
    <li><code>Hoa\String::RTL</code>, pour <em lang="en">right-to-left</em>, si
    le texte s'écrit de droite à gauche.</li>
  </ul>
  <p>Observons le résultat sur nos exemples :</p>
  <pre><code class="language-php">var_dump(
    $french->getDirection()   === Hoa\String::LTR, // is left-to-right?
    $arabic->getDirection()   === Hoa\String::RTL, // is right-to-left?
    $japanese->getDirection() === Hoa\String::LTR  // is left-to-right?
);

/**
 * Will output:
 *     bool(true)
 *     bool(true)
 *     bool(true)
 */</code></pre>
  <p>Le résultat de cette méthode est calculé grâce à la méthode statique
  <code>Hoa\String::getCharDirection</code> qui calcule la direction d'un seul
  caractère.</p>
  <p>Si nous voulons <strong>concaténer</strong> une autre chaîne à la fin ou au
  début, nous utiliserons respectivement les méthodes
  <code>Hoa\String::append</code> et <code>Hoa\String::prepend</code>. Ces
  méthodes, comme la plupart de celles qui modifient la chaîne, retournent
  l'objet lui-même, ce afin de chaîner les méthodes. Par exemple :</p>
  <pre><code class="language-php">echo $french->append('… et toi, m\'aimes-tu ?')->prepend('Mam\'zelle ! ');

/**
 * Will output:
 *     Mam'zelle ! Je t'aime… et toi, m'aimes-tu ?
 */</code></pre>
  <p>Nous avons également les méthodes <code>Hoa\String::toLowerCase</code> et
  <code>Hoa\String::toUpperCase</code> pour, respectivement, mettre la chaîne en
  <strong>minuscules</strong> ou en <strong>majuscules</strong>. Par exemple :</p>
  <pre><code class="language-php">echo $french->toUpperCase();

/**
 * Will output:
 *     MAM'ZELLE ! JE T'AIME… ET TOI, M'AIMES-TU ?
 */</code></pre>
  <p>Nous pouvons aussi ajouter des caractères en début ou en fin de chaîne pour
  atteindre une taille <strong>minimum</strong>. Cette opération est plus
  couramment appelée le <em lang="en">padding</em> (pour des raisons historiques
  remontant aux machines à écrire). C'est pourquoi nous trouvons la
  méthode <code>Hoa\String::pad</code> qui prend trois arguments : la taille
  minimum, les caractères à ajouter et un booléen indiquant si nous devons
  ajouter en fin ou en début de chaîne (par défaut en fin avec
  <code>true</code>).</p>
  <pre><code class="language-php">echo $arabic->pad(20, ' ');

/**
 * Will output:
 *                     أحبك
 */</code></pre>
  <p>Une opération similairement inverse permet de supprimer les
  <strong>espaces</strong> en début et en fin de chaîne grâce à la méthode
  <code>Hoa\String::trim</code>. Par exemple, pour revenir à notre chaîne arabe
  originale :</p>
  <pre><code class="language-php">echo $arabic->trim();

/**
 * Will output:
 *     أحبك
 */</code></pre>
  <p>Nous pouvons également <strong>réduire</strong> la chaîne à une
  <strong>sous-chaîne</strong> en précisant la position du premier caractère
  puis la taille de la sous-chaîne à la méthode
  <code>Hoa\String::reduce</code> :</p>
  <pre><code class="language-php">echo $french->reduce(3, 6)->reduce(2, 4);

/**
 * Will output:
 *     aime
 */</code></pre>
  <p>Si nous voulons obtenir un caractère en particulier, nous pouvons exploiter
  l'interface <code>ArrayAccess</code>. Par exemple, pour obtenir le premier
  caractère de chacun de notre exemple (en les reprenant depuis le début) :</p>
  <pre><code class="language-php">var_dump(
    $french[0],
    $arabic[0],
    $japanese[0]
);

/**
 * Will output:
 *     string(1) "J"
 *     string(2) "أ"
 *     string(3) "私"
 */</code></pre>
  <p>Si nous voulons le dernier caractère, nous utiliserons l'index -1. L'index
  n'est pas borné à la taille de la chaîne. Si jamais l'index dépasse cette
  taille, alors un <em>modulo</em> sera appliqué.</p>
  <p>Nous pouvons aussi modifier ou supprimer un caractère précis avec cette
  méthode. Par exemple :</p>
  <pre><code class="language-php">$french->append(' ?');
$french[-1] = '!';
echo $french;

/**
 * Will output:
 *     Je t'aime !
 */</code></pre>
  <p>Une autre méthode fort utile est la transformation en
  <strong>ASCII</strong>. Attention, ce n'est <em>naturellement</em> pas
  toujours possible. Par exemple, nous pouvons transformer du français en ASCII
  mais pas de l'arabe en ASCII. Ainsi :</p>
  <pre><code class="language-php">$title = new Hoa\String('Un été brûlant sur la côte');
echo $title->toAscii();

/**
 * Will output:
 *     Un ete brulant sur la cote
 */</code></pre>
  <p>Pour que cette méthode fonctionne correctement, il faut que l'extension
  <a href="http://php.net/intl"><code>intl</code></a> soit présente, pour que la
  classe <a href="http://php.net/normalizer"><code>Normalizer</code></a> existe.
  Si cette classe n'existe pas, la méthode <code>Hoa\String::toAscii</code> peut
  quand même essayer une transformation mais moins efficace. Pour cela, il faut
  passer <code>true</code> en seul argument. Ce tour de force est déconseillé
  dans la plupart des cas.</p>
  <p>Plus généralement, pour des changements d'<strong>encodage</strong> brut,
  nous pouvons utiliser la méthode statique <code>Hoa\String::transcode</code>,
  avec en premier argument une chaîne de caractères, en deuxième argument
  l'encodage d'origine et en dernier argument l'encodage final souhaité (par
  défaut UTF-8). Pour la liste des encodages, il faut se reporter à l'extension
  <a href="http://php.net/iconv"><code>iconv</code></a> ou entrer la commande
  suivante dans un terminal :</p>
  <pre><code class="language-php">$ iconv --list</code></pre>
  <p>Pour savoir si une chaîne est encodée en UTF-8, nous pouvons utiliser la
  méthode statique <code>Hoa\String::isUtf8</code> ; par exemple :</p>
  <pre><code class="language-php">var_dump(
    Hoa\String::isUtf8('a'),
    Hoa\String::isUtf8(Hoa\String::transcode('a', 'UTF-8', 'UTF-16'))
);

/**
 * Will output:
 *     bool(true)
 *     bool(false)
 */</code></pre>
  <p>Nous pouvons <strong>éclater</strong> la chaîne en plusieurs sous-chaînes
  en utilisant la méthode <code>Hoa\String::split</code>. En premier argument,
  nous avons une expression régulière (type
  <a href="http://pcre.org/">PCRE</a>), puis un entier représentant le nombre
  maximum d'éléments à retourner et enfin une combinaison de constantes. Ces
  constantes sont les suivantes :</p>
  <ul>
    <li><code>Hoa\String::WITHOUT_EMPTY</code> pour que les sous-chaînes vides
    ne soient pas retournées ;</li>
    <li><code>Hoa\String::WITH_DELIMITERS</code> pour que les expressions
    délimitées soient capturées et retournées ;</li>
    <li><code>Hoa\String::WITH_OFFSET</code> pour que la position des
    sous-chaînes soit ajoutée.</li>
  </ul>
  <p>Par défaut, le deuxième argument vaut -1, qui symbolise l'infini, et le
  dernier argument vaut <code>Hoa\String::WITHOUT_EMPTY</code>. Ainsi, si nous
  voulons obtenir tous les mots d'une chaîne, nous écrirons :</p>
  <pre><code class="language-php">print_r($title->split('#\b|\s#'));

/**
 * Will output:
 *     Array
 *     (
 *         [0] => Un
 *         [1] => ete
 *         [2] => brulant
 *         [3] => sur
 *         [4] => la
 *         [5] => cote
 *     )
 */</code></pre>
  <p>Si nous voulons <strong>itérer</strong> sur tous les
  <strong>caractères</strong>, il est préférable d'exploiter l'interface
  <code>IteratorAggregate</code>, soit la méthode
  <code>Hoa\String::getIterator</code>. Voyons plutôt sur l'exemple en
  arabe :</p>
  <pre><code class="language-php">foreach($arabic as $letter)
    echo $letter, "\n";

/**
 * Will output:
 *     أ
 *     ح
 *     ب
 *     ك
 */</code></pre>
  <p>Nous remarquons que l'itération se fait suivant la direction du texte,
  c'est à dire que le premier élément de l'itération est la première lettre de
  la chaîne en partant du début.</p>
  <p>Bien sûr, si nous voulons obtenir un tableau des caractères, nous pouvons
  utiliser la fonction
  <a href="http://php.net/iterator_to_array"><code>iterator_to_array</code></a>
  de PHP :</p>
  <pre><code class="language-php">print_r(iterator_to_array($arabic));

/**
 * Will output:
 *     Array
 *     (
 *         [0] => أ
 *         [1] => ح
 *         [2] => ب
 *         [3] => ك
 *     )
 */</code></pre>
  <p>Si cette fois nous ne nous intéressons pas aux caractères Unicode mais aux
  caractères <strong>machines</strong> <code>char</code> (soit 1 octet), nous
  avons quelques opérations supplémentaires. La première est
  <code>Hoa\String::getBytesLength</code> qui va compter la
  <strong>taille</strong> de la chaîne en octets :</p>
  <pre><code class="language-php">var_dump(
    $arabic->getBytesLength(),
    $japanese->getBytesLength()
);

/**
 * Will output:
 *     int(8)
 *     int(27)
 */</code></pre>
  <p>Si nous comparons ces résultats avec ceux de la méthode
  <code>Hoa\String::count</code>, nous comprenons que les caractères arabes sont
  encodés sur 2 octets alors que les caractères japonais sont encodés sur 3
  octets. Nous pouvons également obtenir un octet précis à l'aide de la méthode
  <code>Hoa\String::getByteAt</code>. Encore une fois, l'index n'est pas
  borné.</p>
  <p>Enfin, une autre méthode bien pratique est
  <code>Hoa\String::getWidth</code> qui calcule la <strong>largeur</strong>
  d'une chaîne, c'est à dire le nombre de colonnes utilisées par cette chaîne
  lors de son affichage. Ainsi :</p>
  <pre><code class="language-php">var_dump(
    $french->getWidth(),
    $arabic->getWidth(),
    $japanese->getWidth()
);

/**
 * Will output:
 *     int(9)
 *     int(4)
 *     int(18)
 */</code></pre>
  <p>Essayez dans un terminal avec une police <strong>mono-espacée</strong>.
  Vous verrez que le japonais demande 18 colonnes pour s'afficher. Cette mesure
  est très utile si nous voulons connaître la largeur d'une chaîne pour la
  positionner efficacement.</p>

  <h3 id="Comparaison_et_recherche" for="main-toc">Comparaison et recherche</h3>

  <p>Les chaînes peuvent également être <strong>comparées</strong> entre elles
  grâce à la méthode <code>Hoa\String::compare</code> :</p>
  <pre><code class="language-php">$string = new Hoa\String('abc');
var_dump(
    $string->compare('wxyz')
);

/**
 * Will output:
 *     string(-1)
 */</code></pre>
  <p>Cette méthode retourne -1 si la chaîne initiale vient avant (par ordre
  alphabétique), 0 si elle est identique, et 1 si elle vient après. Si nous
  voulons utiliser la pleine
  puissance du mécanisme sous-jacent, nous pouvons appeler la méthode statique
  <code>Hoa\String::getCollator</code> (si la classe
  <a href="http://php.net/Collator"><code>Collator</code></a> existe, auquel
  cas, <code>Hoa\String::compare</code> utilisera une comparaison simple octet
  par octets sans tenir compte d'autres paramètres). Ainsi, si nous voulons
  trier un tableau de chaînes, nous écrirons plutôt :</p>
  <pre><code class="language-php">$strings = array('c', 'Σ', 'd', 'x', 'α', 'a');
Hoa\String::getCollator()->sort($strings);
print_r($strings);

/**
 * Could output:
 *     Array
 *     (
 *         [0] => a
 *         [1] => c
 *         [2] => d
 *         [3] => x
 *         [4] => α
 *         [5] => Σ
 *     )
 */</code></pre>
  <p>La comparaison entre deux chaînes dépend de la <strong>locale</strong>,
  c'est à dire de la régionalisation du système, comme la langue, le pays, la
  région etc. Nous pouvons utiliser <a href="@lh:chapter=Locale">la bibliothèque
  <code>Hoa\Locale</code></a> pour modifier ces données mais ce n'est pas une
  dépendance de <code>Hoa\String</code> pour autant.</p>
  <p>Nous pouvons également savoir si une chaîne <strong>correspond</strong> à
  un certain motif, toujours exprimé avec une expression régulière. Pour cela,
  nous allons utiliser la méthode <code>Hoa\String::match</code>. Cette méthode
  repose sur les fonctions
  <a href="http://php.net/preg_match"><code>preg_match</code></a> et
  <a href="http://php.net/preg_match_all"><code>preg_match_all</code></a> de
  PHP, mais en modifiant les options du motif afin qu'il supporte Unicode. Nous
  avons les paramètres suivant : le motif, une variable par référence pour
  récupérer les captures, les <em lang="en">flags</em>, la position de début de
  recherche (<em lang="en">offset</em>) et enfin un booléen indiquant si la
  recherche est globale ou non (respectivement si nous devons utiliser
  <code>preg_match_all</code> ou <code>preg_match</code>). Par défaut, la
  recherche n'est pas globale.</p>
  <p>Ainsi, nous allons vérifier que notre exemple en français contient bien
  <code>aime</code> avec son complément d'objet direct :</p>
  <pre><code class="language-php">$french->match('#(?:(?&amp;lt;direct_object>\w)[\'\b])aime#', $matches);
var_dump($matches['direct_object']);

/**
 * Will output:
 *     string(1) "t"
 */</code></pre>
  <p>Cette méthode retourne <code>false</code> si une erreur est survenue (par
  exemple si le motif n'est pas correct), 0 si aucune correspondance n'a été
  trouvée, le nombre de correspondances trouvées sinon.</p>
  <p>Similairement, nous pouvons <strong>chercher</strong> et
  <strong>remplacer</strong> des sous-chaînes par d'autres sous-chaînes suivant
  un motif, toujours exprimé avec une expression régulière. Pour cela, nous
  allons utiliser la méthode <code>Hoa\String::replace</code>. Cette méthode
  repose sur les fonctions
  <a href="http://php.net/preg_replace"><code>preg_replace</code></a> et
  <a href="http://php.net/preg_replace_callback"><code>preg_replace_callback</code></a>
  de PHP, mais toujours en modifiant les options du motif afin qu'il supporte
  Unicode. En premier argument, nous trouvons le ou les motifs, en deuxième
  argument, le ou les remplacements et en dernier argument la limite de
  remplacements à faire. Si le remplacement est un <em lang="en">callable</em>,
  alors la fonction <code>preg_replace_callback</code> sera utilisée.</p>
  <p>Ainsi, nous allons modifier notre exemple français pour qu'il soit plus
  poli :</p>
  <pre><code class="language-php">$french->replace('#(?:\w[\'\b])(?&amp;lt;verb>aime)#', function ( $matches ) {

    return 'vous ' . $matches['verb'];
});

echo $french;

/**
 * Will output:
 *     Je vous aime
 */</code></pre>

  <h3 id="Code-point" for="main-toc">Code-point</h3>

  <p>Chaque caractère est représenté en machine par un entier, appelé
  <strong>code-point</strong>. Pour obtenir le code-point d'un caractère, nous
  pouvons utiliser la méthode statique <code>Hoa\String::toCode</code>, et pour
  obtenir un caractère à partir d'un code, nous pouvons utiliser la méthode
  statique <code>Hoa\String::fromCode</code>. Nous avons aussi la méthode
  statique <code>Hoa\String::toBinaryCode</code> qui retourne la représentation
  sous forme binaire d'un caractère. Prenons un exemple :</p>
  <pre><code class="language-php">var_dump(
    Hoa\String::toCode('Σ'),
    Hoa\String::toBinaryCode('Σ'),
    Hoa\String::fromCode(0x1a9)
);

/**
 * Will output:
 *     int(931)
 *     string(32) "00000000000000000000001110100011"
 *     string(2) "Σ"
 */</code></pre>
  <p>Nous pouvons préciser la taille de la représentation binaire à l'aide du
  second argument de la méthode <code>Hoa\String::toBinaryCode</code> (32 par
  défaut).</p>

  <h2 id="Algorithmes_de_recherche" for="main-toc">Algorithmes de recherche</h2>

  <p>La bibliothèque <code>Hoa\String</code> propose des algorithmes de
  <strong>recherches</strong> sophistiquées sur les chaînes de caractères à
  travers la classe <code>Hoa\String\Search</code>.</p>
  <p>Nous allons étudier l'algorithme
  <code>Hoa\String\Search::approximated</code> qui fait une recherche d'une
  sous-chaîne dans une chaîne avec au maximum <strong><em>k</em>
  différences</strong> (une différence étant une insertion, une délétion ou une
  modification). Prenons un exemple classique avec une représentation
  ADN : nous allons chercher toutes les sous-chaînes s'approchant de
  <code>GATAA</code> à 1 différence près (au maximum) dans
  <code>CAGATAAGAGAA</code>. Pour cela, nous allons donc écrire :</p>
  <pre><code class="language-php">$x      = 'GATAA';
$y      = 'CAGATAAGAGAA';
$k      = 1;
$search = Hoa\String\Search::approximated($y, $x, $k);
$n      = count($search);

echo 'Try to match ', $x, ' in ', $y, ' with at most ', $k, ' difference(s):', "\n";
echo $n, ' match(es) found:', "\n";

foreach($search as $position)
    echo '    • ', substr($y, $position['i'], $position['l'), "\n";

/**
 * Will output:
 *     Try to match GATAA in CAGATAAGAGAA with at most 1 difference(s):
 *     4 match(es) found:
 *         • AGATA
 *         • GATAA
 *         • ATAAG
 *         • GAGAA
 */</code></pre>
  <p>Cette méthode retourne un tableau de tableaux. Chaque sous-tableau
  représente un résultat et contient trois indexes : <code>i</code> pour la
  position du premier caractère (octet) du résultat, <code>j</code> pour la
  position du dernier caractère et <code>l</code> pour la taille du résultat
  (tout simplement <code>j</code> - <code>i</code>).
  Ainsi, nous pouvons calculer les résultats en utilisant notre chaîne initiale
  (ici <code class="language-php">$y</code>) et ces indexes.</p>
  <p>Avec notre exemple, nous avons quatre résultats. Le premier est
  <code>AGATA</code>, soit <code>GATA<em>A</em></code> avec un caractère
  déplacé, et <code>AGATA</code> existe bien dans
  <code>C<em>AGATA</em>AGAGAA</code>. Le deuxième résultat est
  <code>GATAA</code>, notre sous-chaîne, qui existe belle et bien dans
  <code>CA<em>GATAA</em>GAGAA</code>. Le troisième résultat est
  <code>ATAAG</code>, soit <code><em>G</em>ATAA</code> avec un caractère
  déplacé, et <code>ATAAG</code> existe bien dans
  <code>CAG<em>ATAAG</em>AGAA</code>. Enfin, le dernier résultat est
  <code>GAGAA</code>, soit <code>GA<em>T</em>AA</code> avec un caractère
  modifié, et <code>GAGAA</code> existe bien dans
  <code>CAGATAA<em>GAGAA</em></code>.</p>
  <p>Prenons un autre exemple, plus concret cette fois-ci. Nous allons
  considérer la chaîne <code>--testIt --foobar --testThat --testAt</code> (qui
  représente les options possible d'une ligne de commande), et nous allons
  chercher <code>--testot</code>, une option qu'aurait pu donner
  l'utilisateur. Cette option n'existe pas telle quelle. Nous allons donc
  utiliser notre algorithme de recherche avec 1 différence au maximum. Voyons
  plutôt :</p>
  <pre><code class="language-php">$x      = 'testot';
$y      = '--testIt --foobar --testThat --testAt';
$k      = 1;
$search = Hoa\String\Search::approximated($y, $x, $k);
$n      = count($search);

// …

/**
 * Will output:
 *     Try to match testot in --testIt --foobar --testThat --testAt with at most 1 difference(s)
 *     2 match(es) found:
 *         • testIt
 *         • testAt
 */</code></pre>
  <p>Les résultats <code>testIt</code> et <code>testAt</code> sont des vraies
  options, donc nous pouvons les proposer à l'utilisateur. C'est un mécanisme
  utilisé par <code>Hoa\Console</code> pour proposer des corrections à
  l'utilisateur s'il se trompe.</p>

  <h2 id="Conclusion" for="main-toc">Conclusion</h2>

  <p>La classe <code>Hoa\String</code> propose des facilités pour manipuler des
  chaînes encodées au format Unicode, mais aussi pour effectuer des recherches
  sophistiquées sur des chaînes.</p>

</yield>
</overlay>
